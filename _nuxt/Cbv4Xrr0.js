import{a5 as S,a0 as x,a1 as U,az as H,$ as Q,a3 as v,ax as oo,ac as g,aW as no,aq as k,aj as io,aU as so,aV as eo,aX as W,aY as to,aZ as q,a_ as ao,a2 as X,as as Z,a$ as y,b0 as d,aG as J,b1 as P,a7 as $,Y as R,ag as O}from"./D6SZilkK.js";const L=.5,w=0,m=1,j=60,G=0,ro=.01;function uo(n){const o=n.initialPosition,{dx:i,dy:s}=S(o,n.position),e=Math.abs(i),a=Math.abs(s),{maxDistance:t}=n.retina,u=t.horizontal,r=t.vertical;if(!u&&!r)return;const f=(u&&e>=u)??!1,h=(r&&a>=r)??!1;if((f||h)&&!n.misplaced)n.misplaced=!!u&&e>u||!!r&&a>r,u&&(n.velocity.x=n.velocity.y*L-n.velocity.x),r&&(n.velocity.y=n.velocity.x*L-n.velocity.y);else if((!u||e<u)&&(!r||a<r)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const l=n.position,c=n.velocity;u&&(l.x<o.x&&c.x<w||l.x>o.x&&c.x>w)&&(c.x*=-x()),r&&(l.y<o.y&&c.y<w||l.y>o.y&&c.y>w)&&(c.y*=-x())}}function fo(n,o,i,s,e,a){ho(n,a);const t=n.gravity,u=t!=null&&t.enable&&t.inverse?-m:m;e&&i&&(n.velocity.x+=e*a.factor/(j*i)),t!=null&&t.enable&&i&&(n.velocity.y+=u*(t.acceleration*a.factor)/(j*i));const r=n.moveDecay;n.velocity.multTo(r);const f=n.velocity.mult(i);t!=null&&t.enable&&s>w&&(!t.inverse&&f.y>=w&&f.y>=s||t.inverse&&f.y<=w&&f.y<=-s)&&(f.y=u*s,i&&(n.velocity.y=f.y/i));const h=n.options.zIndex,l=(m-n.zIndexFactor)**h.velocityRate;f.multTo(l);const{position:c}=n;c.addTo(f),o.vibrate&&(c.x+=Math.sin(c.x*Math.cos(c.y)),c.y+=Math.cos(c.y*Math.sin(c.x)))}function co(n,o){const i=n.container;if(!n.spin)return;const s={x:n.spin.direction===U.clockwise?Math.cos:Math.sin,y:n.spin.direction===U.clockwise?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*s.x(n.spin.angle),n.position.y=n.spin.center.y+n.spin.radius*s.y(n.spin.angle),n.spin.radius+=n.spin.acceleration;const e=Math.max(i.canvas.size.width,i.canvas.size.height),a=e*L;n.spin.radius>a?(n.spin.radius=a,n.spin.acceleration*=-m):n.spin.radius<G&&(n.spin.radius=G,n.spin.acceleration*=-m),n.spin.angle+=o*ro*(m-n.spin.radius/e)}function ho(n,o){var t;const i=n.options,s=i.move.path;if(!s.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=o.value;return}const a=(t=n.pathGenerator)==null?void 0:t.generate(n,o);a&&n.velocity.addTo(a),s.clamp&&(n.velocity.x=H(n.velocity.x,-m,m),n.velocity.y=H(n.velocity.y,-m,m)),n.lastPathTime-=n.pathDelay}function yo(n){return n.slow.inRange?n.slow.factor:m}function lo(n){const o=n.container,i=n.options,s=i.move.spin;if(!s.enable)return;const e=s.position??{x:50,y:50},a=.01,t={x:e.x*a*o.canvas.size.width,y:e.y*a*o.canvas.size.height},u=n.getPosition(),r=Q(u,t),f=v(s.acceleration);n.retina.spinAcceleration=f*o.retina.pixelRatio;const h=0;n.spin={center:t,direction:n.velocity.x>=h?U.clockwise:U.counterClockwise,angle:n.velocity.angle,radius:r,acceleration:n.retina.spinAcceleration}}const vo=2,mo=1,go=1;class xo{init(o){const i=o.options,s=i.move.gravity;o.gravity={enable:s.enable,acceleration:v(s.acceleration),inverse:s.inverse},lo(o)}isEnabled(o){return!o.destroyed&&o.options.move.enable}move(o,i){var B,I;const s=o.options,e=s.move;if(!e.enable)return;const a=o.container,t=a.retina.pixelRatio;(B=o.retina).moveSpeed??(B.moveSpeed=v(e.speed)*t),(I=o.retina).moveDrift??(I.moveDrift=v(o.options.move.drift)*t);const u=yo(o),r=o.retina.moveSpeed*a.retina.reduceFactor,f=o.retina.moveDrift,h=oo(s.size.value)*t,l=e.size?o.getRadius()/h:mo,c=i.factor||go,E=r*l*u*c/vo,K=o.retina.maxSpeed??a.retina.maxSpeed;e.spin.enable?co(o,E):fo(o,e,E,K,f,i),uo(o)}}async function bo(n,o=!0){g(n,"3.7.1"),await n.addMover("base",()=>Promise.resolve(new xo),o)}const po=2,wo=Math.PI*po,zo=0,N={x:0,y:0};function Mo(n){const{context:o,particle:i,radius:s}=n;i.circleRange||(i.circleRange={min:zo,max:wo});const e=i.circleRange;o.arc(N.x,N.y,s,e.min,e.max,!1)}const Po=12,Co=360,Y=0;class So{constructor(){this.validTypes=["circle"]}draw(o){Mo(o)}getSidesCount(){return Po}particleInit(o,i){const s=i.shapeData,e=(s==null?void 0:s.angle)??{max:Co,min:Y};i.circleRange=no(e)?{min:k(e.min),max:k(e.max)}:{min:Y,max:k(e)}}}async function Ro(n,o=!0){g(n,"3.7.1"),await n.addShape(new So,o)}class Oo{constructor(o,i){this._container=o,this._engine=i}init(o){const i=io(this._engine,o.options.color,o.id,o.options.reduceDuplicates);i&&(o.color=so(i,o.options.color.animation,this._container.retina.reduceFactor))}isEnabled(o){const{h:i,s,l:e}=o.options.color.animation,{color:a}=o;return!o.destroyed&&!o.spawning&&((a==null?void 0:a.h.value)!==void 0&&i.enable||(a==null?void 0:a.s.value)!==void 0&&s.enable||(a==null?void 0:a.l.value)!==void 0&&e.enable)}update(o,i){eo(o.color,i)}}async function Do(n,o=!0){g(n,"3.7.1"),await n.addParticleUpdater("color",i=>Promise.resolve(new Oo(i,n)),o)}var p;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=4]="a"})(p||(p={}));const Fo=/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,Vo=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i,D=16,Ao=1,_o=255;class Uo{constructor(){this.key="hex",this.stringPrefix="#"}handleColor(o){return this._parseString(o.value)}handleRangeColor(o){return this._parseString(o.value)}parseString(o){return this._parseString(o)}_parseString(o){if(typeof o!="string"||!(o!=null&&o.startsWith(this.stringPrefix)))return;const i=o.replace(Fo,(e,a,t,u,r)=>a+a+t+t+u+u+(r!==void 0?r+r:"")),s=Vo.exec(i);return s?{a:s[p.a]!==void 0?parseInt(s[p.a],D)/_o:Ao,b:parseInt(s[p.b],D),g:parseInt(s[p.g],D),r:parseInt(s[p.r],D)}:void 0}}async function To(n,o=!0){g(n,"3.7.1"),await n.addColorManager(new Uo,o)}var z;(function(n){n[n.h=1]="h",n[n.s=2]="s",n[n.l=3]="l",n[n.a=5]="a"})(z||(z={}));class ko{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.s!==void 0&&s.l!==void 0)return W(s)}handleRangeColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.l!==void 0)return W({h:v(s.h),l:v(s.l),s:v(s.s)})}parseString(o){if(!o.startsWith("hsl"))return;const i=/hsla?\(\s*(\d+)\s*[\s,]\s*(\d+)%\s*[\s,]\s*(\d+)%\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=4,a=1,t=10;return s?to({a:s.length>e?q(s[z.a]):a,h:parseInt(s[z.h],t),l:parseInt(s[z.l],t),s:parseInt(s[z.s],t)}):void 0}}async function Lo(n,o=!0){g(n,"3.7.1"),await n.addColorManager(new ko,o)}class $o{constructor(o){this.container=o}init(o){const i=o.options.opacity,s=1;o.opacity=ao(i,s);const e=i.animation;e.enable&&(o.opacity.velocity=v(e.speed)/X*this.container.retina.reduceFactor,e.sync||(o.opacity.velocity*=x()))}isEnabled(o){return!o.destroyed&&!o.spawning&&!!o.opacity&&o.opacity.enable&&((o.opacity.maxLoops??0)<=0||(o.opacity.maxLoops??0)>0&&(o.opacity.loops??0)<(o.opacity.maxLoops??0))}reset(o){o.opacity&&(o.opacity.time=0,o.opacity.loops=0)}update(o,i){!this.isEnabled(o)||!o.opacity||Z(o,o.opacity,!0,o.options.opacity.animation.destroy,i)}}async function Eo(n,o=!0){g(n,"3.7.1"),await n.addParticleUpdater("opacity",i=>Promise.resolve(new $o(i)),o)}const T=0,C=0;function Bo(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==d.left&&n.direction!==d.right)return;n.bounds.right<C&&n.direction===d.left?n.particle.position.x=n.size+n.offset.x:n.bounds.left>n.canvasSize.width&&n.direction===d.right&&(n.particle.position.x=n.canvasSize.width-n.size-n.offset.x);const o=n.particle.velocity.x;let i=!1;if(n.direction===d.right&&n.bounds.right>=n.canvasSize.width&&o>T||n.direction===d.left&&n.bounds.left<=C&&o<T){const e=v(n.particle.options.bounce.horizontal.value);n.particle.velocity.x*=-e,i=!0}if(!i)return;const s=n.offset.x+n.size;n.bounds.right>=n.canvasSize.width&&n.direction===d.right?n.particle.position.x=n.canvasSize.width-s:n.bounds.left<=C&&n.direction===d.left&&(n.particle.position.x=s),n.outMode===y.split&&n.particle.destroy()}function Io(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==d.bottom&&n.direction!==d.top)return;n.bounds.bottom<C&&n.direction===d.top?n.particle.position.y=n.size+n.offset.y:n.bounds.top>n.canvasSize.height&&n.direction===d.bottom&&(n.particle.position.y=n.canvasSize.height-n.size-n.offset.y);const o=n.particle.velocity.y;let i=!1;if(n.direction===d.bottom&&n.bounds.bottom>=n.canvasSize.height&&o>T||n.direction===d.top&&n.bounds.top<=C&&o<T){const e=v(n.particle.options.bounce.vertical.value);n.particle.velocity.y*=-e,i=!0}if(!i)return;const s=n.offset.y+n.size;n.bounds.bottom>=n.canvasSize.height&&n.direction===d.bottom?n.particle.position.y=n.canvasSize.height-s:n.bounds.top<=C&&n.direction===d.top&&(n.particle.position.y=s),n.outMode===y.split&&n.particle.destroy()}class Ho{constructor(o){this.container=o,this.modes=[y.bounce,y.split]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;let t=!1;for(const c of a.plugins.values())if(c.particleBounce!==void 0&&(t=c.particleBounce(o,s,i)),t)break;if(t)return;const u=o.getPosition(),r=o.offset,f=o.getRadius(),h=J(u,f),l=a.canvas.size;Bo({particle:o,outMode:e,direction:i,bounds:h,canvasSize:l,offset:r,size:f}),Io({particle:o,outMode:e,direction:i,bounds:h,canvasSize:l,offset:r,size:f})}}const F=0;class Wo{constructor(o){this.container=o,this.modes=[y.destroy]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case P.normal:case P.outside:if($(o.position,a.canvas.size,R.origin,o.getRadius(),i))return;break;case P.inside:{const{dx:t,dy:u}=S(o.position,o.moveCenter),{x:r,y:f}=o.velocity;if(r<F&&t>o.moveCenter.radius||f<F&&u>o.moveCenter.radius||r>=F&&t<-o.moveCenter.radius||f>=F&&u<-o.moveCenter.radius)return;break}}a.particles.remove(o,o.group,!0)}}const V=0;class jo{constructor(o){this.container=o,this.modes=[y.none]}update(o,i,s,e){if(!this.modes.includes(e)||((o.options.move.distance.horizontal&&(i===d.left||i===d.right))??(o.options.move.distance.vertical&&(i===d.top||i===d.bottom))))return;const a=o.options.move.gravity,t=this.container,u=t.canvas.size,r=o.getRadius();if(a.enable){const f=o.position;(!a.inverse&&f.y>u.height+r&&i===d.bottom||a.inverse&&f.y<-r&&i===d.top)&&t.particles.remove(o)}else{if(o.velocity.y>V&&o.position.y<=u.height+r||o.velocity.y<V&&o.position.y>=-r||o.velocity.x>V&&o.position.x<=u.width+r||o.velocity.x<V&&o.position.x>=-r)return;$(o.position,t.canvas.size,R.origin,r,i)||t.particles.remove(o)}}}const A=0,_=0;class Go{constructor(o){this.container=o,this.modes=[y.out]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case P.inside:{const{x:t,y:u}=o.velocity,r=R.origin;r.length=o.moveCenter.radius,r.angle=o.velocity.angle+Math.PI,r.addTo(R.create(o.moveCenter));const{dx:f,dy:h}=S(o.position,r);if(t<=A&&f>=_||u<=A&&h>=_||t>=A&&f<=_||u>=A&&h<=_)return;o.position.x=Math.floor(O({min:0,max:a.canvas.size.width})),o.position.y=Math.floor(O({min:0,max:a.canvas.size.height}));const{dx:l,dy:c}=S(o.position,o.moveCenter);o.direction=Math.atan2(-c,-l),o.velocity.angle=o.direction;break}default:{if($(o.position,a.canvas.size,R.origin,o.getRadius(),i))return;switch(o.outType){case P.outside:{o.position.x=Math.floor(O({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.x,o.position.y=Math.floor(O({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.y;const{dx:t,dy:u}=S(o.position,o.moveCenter);o.moveCenter.radius&&(o.direction=Math.atan2(u,t),o.velocity.angle=o.direction);break}case P.normal:{const t=o.options.move.warp,u=a.canvas.size,r={bottom:u.height+o.getRadius()+o.offset.y,left:-o.getRadius()-o.offset.x,right:u.width+o.getRadius()+o.offset.x,top:-o.getRadius()-o.offset.y},f=o.getRadius(),h=J(o.position,f);i===d.right&&h.left>u.width+o.offset.x?(o.position.x=r.left,o.initialPosition.x=o.position.x,t||(o.position.y=x()*u.height,o.initialPosition.y=o.position.y)):i===d.left&&h.right<-o.offset.x&&(o.position.x=r.right,o.initialPosition.x=o.position.x,t||(o.position.y=x()*u.height,o.initialPosition.y=o.position.y)),i===d.bottom&&h.top>u.height+o.offset.y?(t||(o.position.x=x()*u.width,o.initialPosition.x=o.position.x),o.position.y=r.top,o.initialPosition.y=o.position.y):i===d.top&&h.bottom<-o.offset.y&&(t||(o.position.x=x()*u.width,o.initialPosition.x=o.position.x),o.position.y=r.bottom,o.initialPosition.y=o.position.y);break}}break}}}}const No=(n,o)=>n.default===o||n.bottom===o||n.left===o||n.right===o||n.top===o;class Yo{constructor(o){this._addUpdaterIfMissing=(i,s,e)=>{const a=i.options.move.outModes;!this.updaters.has(s)&&No(a,s)&&this.updaters.set(s,e(this.container))},this._updateOutMode=(i,s,e,a)=>{for(const t of this.updaters.values())t.update(i,a,s,e)},this.container=o,this.updaters=new Map}init(o){this._addUpdaterIfMissing(o,y.bounce,i=>new Ho(i)),this._addUpdaterIfMissing(o,y.out,i=>new Go(i)),this._addUpdaterIfMissing(o,y.destroy,i=>new Wo(i)),this._addUpdaterIfMissing(o,y.none,i=>new jo(i))}isEnabled(o){return!o.destroyed&&!o.spawning}update(o,i){const s=o.options.move.outModes;this._updateOutMode(o,i,s.bottom??s.default,d.bottom),this._updateOutMode(o,i,s.left??s.default,d.left),this._updateOutMode(o,i,s.right??s.default,d.right),this._updateOutMode(o,i,s.top??s.default,d.top)}}async function qo(n,o=!0){g(n,"3.7.1"),await n.addParticleUpdater("outModes",i=>Promise.resolve(new Yo(i)),o)}var M;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=5]="a"})(M||(M={}));class Xo{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return s}handleRangeColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return{r:v(s.r),g:v(s.g),b:v(s.b)}}parseString(o){if(!o.startsWith(this.stringPrefix))return;const i=/rgba?\(\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=10;return s?{a:s.length>4?q(s[M.a]):1,b:parseInt(s[M.b],e),g:parseInt(s[M.g],e),r:parseInt(s[M.r],e)}:void 0}}async function Zo(n,o=!0){g(n,"3.7.1"),await n.addColorManager(new Xo,o)}const b=0;class Jo{init(o){const i=o.container,s=o.options.size,e=s.animation;e.enable&&(o.size.velocity=(o.retina.sizeAnimationSpeed??i.retina.sizeAnimationSpeed)/X*i.retina.reduceFactor,e.sync||(o.size.velocity*=x()))}isEnabled(o){return!o.destroyed&&!o.spawning&&o.size.enable&&((o.size.maxLoops??b)<=b||(o.size.maxLoops??b)>b&&(o.size.loops??b)<(o.size.maxLoops??b))}reset(o){o.size.loops=b}update(o,i){this.isEnabled(o)&&Z(o,o.size,!0,o.options.size.animation.destroy,i)}}async function Ko(n,o=!0){g(n,"3.7.1"),await n.addParticleUpdater("size",()=>Promise.resolve(new Jo),o)}async function on(n,o=!0){g(n,"3.7.1"),await To(n,!1),await Lo(n,!1),await Zo(n,!1),await bo(n,!1),await Ro(n,!1),await Do(n,!1),await Eo(n,!1),await qo(n,!1),await Ko(n,!1),await n.refresh(o)}export{on as loadBasic};
